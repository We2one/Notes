### MySQL 数据库



##### 多表查询

 1. ##### 嵌套查询 (将一条 sql 语句作为另一条 sql 语句的查询条件使用)

    + 基础格式

      ```mysql
      select * 
      from tab_name 
      where 字段名 
      in (
          select 字段 
          from tab_name
      );
      ```

    + 单行子查询
    + 多行子查询

	2. ##### 关联查询 (不推荐使用, 一次性查询多张表,使用 where 条件将关键字进行关联,如果有多个关联条件直接以 and 添加)

    + 基础格式

      ```mysql
      select * 
      from tab_name1, tab_name2
      where
      关联条件;
      ```

	3. ##### 连接查询

    	1. 内连接 (inner join , inner 可以省略)

        + 基础格式

          ```mysql
          select * 
          from tab_name1 inner join tab_name2 
          on 关联条件 
          where 条件;
          ```

        + 内连接查询的结果和 where关联查询的结果一样. 只能查询出有关联

          的数据

    2. 左外连接

       + 基础格式

         ```mysql
         select *
         from left_tab_name left join right_tab_name 
         on 关联条件
         where 条件;
         ```

       + 以左表为主表,将左表中所有的数据查询出来向右表进行匹配,如果右表没有对应的额数据,以null填充.

    3. 右外连接

       + 基础格式

         ```mysql
         select *
         from left_tab_name right join right_tab_name
         on 关联条件
         where 条件;
         ```

       + 以右表为主表,将右表所有的数据查询出来,向左表匹配,如果左表没有对应的数据,以null占位

#### 事务

 1. ##### 将 ***一组有序***  的 增 删 改 操作,当做一个独立的执行单元,如果这一组操作中有一个执行失败,整个事务则失败,自动执行回滚操作,当这一组操作都执行成功的情况下,事务则执行成功. (事务就是一组数据库操作的集合,一起执行一起失败)

 2. ##### 数据库引擎

    + 概述 : 数据库存储引擎 ———— 数据库底层构建的核心,负责 底层数据持久化 和 软件交互的序列化 操作、校验过程、交互过程, 通过数据库存储引擎完成 创建、查询、更新 和 删除 数据
    + InnoDB 引擎
      + mysql 5.5 版本之后的默认引擎, **支持事务、外键、行级锁**， 相对效率低
      + 主要应用 : 数据安全
    + MyISAM 引擎
      + 不支持 **事务、外键**
      + 有较高的插入、查询速度

3. ##### 事务的特性 (ACID)

   + 原子性 (Atomicity)
     + 一个事务是不可分割的,事务中有一个操作失败,整个事务就会执行失败,自动回滚
   + 一致性 (Consistency)
     + 描述事务的状态,事务执行前和执行后状态保值一定
   + 隔离性 (Isolation)
     + 当多个用户并发访问时,系统会给每一个开启的线程开启一个事务,事务于事务之间相互隔离互不影响
   + 持久性 (Durability)
     + 一旦事务提交,事务对数据的操作,会被永久存储在数据库中

4. ##### 事务的并发问题 (不考虑隔离性的情况下，会出现)

   1. 脏读 (Dirty Read)
      + A 事务 读取到了还未提交的 B 事务更新的**一条数据**, 并且对此数据进行了操作, 然后B 事务回滚, 那么 A 事务读到的数据是不合法的数据
   2. 不可重复读 (Unrepeatable Read)
      + 两个事务对一条数据操作, A 先读取**一条数据**,B之后**更改**此数据并提交, A 再次读取就会发现读取到的数据与上次不同
   3. 幻读 (Phantom Read)
      + 两个事务 A, B , A 读取了**一张表的数据**之后, B 向表内**插入数据**, A 再次读取就会发现数据增多了

5. ##### 事务的隔离级别 (限定事务内外哪些改变可见,哪些不可见)

   1. Read Uncommitted (读 未提交)
      + 只对修改数据的并发操作做限制. 
      + 一个事务不能修改其他事务正在修改的数据, 但可以读取到**其他事务尚未提交的修改**, 这些修改如果未被提交,将会成为脏数据
      + 会出现脏数据
   2. Read committed (读 已提交)
      + 只允许读取已经被提交的数据
      + 如果一个事务修改了某行数据且尚未提交,而第二个事务需要读取此数据的话是不被允许的,读取的是未提交前的数据,
      + 防止脏读的出现,可能会出现不可重复读问题
   3. Repeatable read (可重复 读)
      + 读取其间其他事务不允许更新
      + 开始读取事务 (事务开启时) , 不在允许修改操作, 
      + 防止不可重复读现象出现
   4. Serializable (可串行化)
      + 所有的事务必需串行化执行
      + 只要有事务在对表进行查询,那么此事务提交前,所有其它事务的修改都会被阻塞

6. ##### 事务操作

   1. 设置事务隔离级别 (隔离级别越高,效率越低)

      ```mysql
      set session transaction isolation level 隔离级别;
      ```

   2. 开启一个事务

      ```mysql
      begin;
      ```

   3. 提交一个事务

      ```mysql
      commit;
      ```

   4. 回滚一个事务

      ```mysql
      rollback;
      ```

      