# 面向对象

+ 对象的拓展
    + __new(cls, args, *kwargs) : 创建对象实例方法 (最先被调用) ，实例化时先 __new 在 __init__
    + 当你继承一些不可变的class时(比如int, str, tuple)， 提供给你一个自定义这些类的实例化过程的途径。还有就是实现自定义的metaclass。
    + \_\_init__(self) : 类的构造函数或初始化方法，可以让创建对象更加灵活
    + \_\_str__(self) : 目标是可读性，或者说，str__的结果是让人看的。打印对象的属性信息，方便我们调试代码。
    + \_\_repr__(self) : 目标是准确性，或者说，repr__的结果是让解释器用的,转化为供解释器读取的形式
    + \_\_del__(self) :  当一个对象被从内存中销毁前(把这个对象从内存中删除掉),会自动调用del__方法
    + \_\_dict__ : 类的属性（包含一个字典，由类的数据属性组成）
    + \_\_doc__ : 类的文档字符串
    + \_\_module: 类定义所在的模块（类的全名是'__main.className'，如果类位于一个导入模块mymod中，那么className.__module__ 等于 mymod）
    + \_\_bases__ : 类的所有父类构成元素（包含了一个由所有父类组成的元组）
    + \_\_cmp__ ( self, x ) : 对象比较, 简单的调用方法 : cmp(obj, x)
    
+ 对象的三大特性:
    + 继承(多继承) : 体现了基于类的代码复用,通过继承关系可以关联两个类 (父类、子类 : 子类继承父类)
        + 基本语法与实现
            ````
          class Father:
                ```父类```
          
          class Child(Father):
                ````子类```
          ````
        + 实现继承
            + 调用父类中的方法直接使用/初始化父类方法
        + 方法的覆盖/重写
            + 覆盖 : 在子类中定义与父类名称相同的方法 就会覆盖父类方法
            + 重写 : 子类继承父类方法后对父类方法进行重新定义
        + 子类访问父类属性/方法
            + super().继承方法名()
        + 多继承 : 多继承模式下继承顺序,使用了广度优先的查询原则
            + Python 提供了 mro() 方法用于确定继承关系中属性和方法的查询操作顺序
    + 封装 `将数据包含、包裹起来,通过封装可以有效完成数据的保护`
        + 将一个对象的数据隐藏在对象内部,不让外界直接访问,而是通过对象提供的方法来访问这些隐私的数据,这样就可以在访问方法中添加访问条件限制.目的是对数据的有效组织和数据安全性的保护
        + 属性私有化封装(私有化属性,将类/对象私有化不让外界访问，强行访问: 对象名.\_类名\_属性名)
            ```
          class Person:
            def __init__(self,name,gender):
                self.name = name
                self.gender = gender
          ```
        + 属性私有化 : python层面的操作,底层解释器在解释时将两个下划线开头的属性性进行了自动转换,变成了_类名__属性名的形式,原来的__属性名称已经不存在了,所以不能直接访问,但是可以通过转换后的语法来访问,但是不推荐
        + 数据私有化 :
            + 用在当前类型中的业务流程中,如对象的一个临时计数属性
            + 使用类提供的访问私有属性的方法来获取数据参与类外部的运算(推荐方法)
        + 属性方法访问私有属性 (推荐)
            + 固定语法 : 
                ```
              # 访问获取 私有属性
              def get__name(self):   # get_属性名(self)...
                    return self._name
              # 修改私有属性
              def set__name(self,name):  # set_属性名()...
                    self._name = name
              ```
            + 添加访问限制 :
                + 通过 set/get 访问时设置访问设置
                 ```
                 def get_name(self):
                        if 判断是否有权限:
                            return self.__name
                        return "你没有权限"    
                ```  
        + 自定义属性封装 : 通过类创建的对象,给当前对象自己拓展新的属性, (一般出现在面试题)
            + 类的外部给已经创建的对象添加属性(扩展属性)
                + 好处: 提高了对象的普适性,可以让对象更加适合不同的应用场景
                + 坏处: 破坏了程序的统一性,不同的开发人员,可能扩展同一个属性的名字不一样,最终会导致对象没有办法操作[报错/失控]
            + 类型属性限制:面向对象开发时,类型可以出现哪些属性,可以通过固定于发限制
                + 魔法属性: \_\_slots__  = [] : 可以限制类型中只能出现哪些名称的属性,配合对象外部属性扩展使用
            + 方法按照属性赋值的方式访问:	@property/@上一个方法名.setter
                + @property/@上一个方法名.setter : 对属性作了私有化后,还是想以常规访问属性的方式访问就需要给方法添加装饰器
        
    + 多态 : 特殊的特性，没有固定语法结构,体现的是程序运行过程中的状态改变和行为的多样性.
        + 程序运行中,对象状态的转换和行为的多样行,都是面向对象中多态的体现
        + 实现多态 : 
            + 继承关系来完成角色的关系切换
            + 继承中的方法重写,完成行为方法的切换
            + 代码结构的设计,完成行为的多样性
    