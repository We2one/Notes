### Python 数据分析

#### 数组的合并与拆分

+ **vertical** : 垂直
+ **horizontal** ： 水平

##### 数组的合并

+ `np.hastck(tup)` 或 `np.c_[a, b]` : 水平合并

  + 实例

    ```python
    import numpy as np
    
    arr1 = np.array([1, 2, 1, 4])
    arr2 = np.zeros(4, dtype=int)
    
    arr3 = np.hstack((arr1, arr2))
    print(arr3)  # [1 2 1 4 0 0 0 0]
    ```

    

+ `np.vstack(tup)` 或 `np.r_[a, b]` : 上下合并,需要有相同的行值

  + 实例

    ```python
    import numpy as np
    
    arr1 = np.array([1, 2, 1, 4])
    arr2 = np.zeros(4, dtype=int)
    
    arr3 = np.vstack((arr1, arr2))
    print(arr3)
    """
    [[1 2 1 4]
     [0 0 0 0]]
    """
    ```

    

+ `np.concatenate(arrays, axis=None, out=None)` : 可与实现上下合并和左右合并,将一个数组序列在指定的维度上进行连接`join`

  + 参数

    | 参数       | 描述                                                         |
    | ---------- | ------------------------------------------------------------ |
    | **arrays** | 合并的数组序列(将要合并的数据组织为序列的格式)               |
    | **axis**   | 轴的设置，一维数组只可以左右合并:<br>&emsp;**0** : 默认，第一维度<br>&emsp;**None** : 如果`axis=None`，那么数组将会先展平，再进行join<br>&emsp;**1** : 列方向左右合并 |
    | **out**    | 如果指定了`out`，则将join后的结果输出到`out`指定的数组中，但`shape`必须正确。如果没有指定`out`，则会返回一个匹配大小的数组 |

  + 实例

    ```python
    import numpy as np
    
    arr1 = np.array([1, 2, 1, 4])
    arr2 = np.zeros(4, dtype=int)
    
    arr3 = np.concatenate((arr1, arr2))
    print(arr3)  # [1 2 1 4 0 0 0 0]
    
    arr4 = np.arange(10).reshape(2, 5)
    print(arr4)
    """
    [[0 1 2 3 4]
     [5 6 7 8 9]]
    """
    arr5 = np.arange(10, 20).reshape(2, 5)
    print(arr5)
    """
    [[10 11 12 13 14]
     [15 16 17 18 19]]
    """
    arr6 = np.concatenate((arr4, arr5), axis=1)
    print(arr6)
    """
    [[ 0  1  2  3  4 10 11 12 13 14]
     [ 5  6  7  8  9 15 16 17 18 19]]
    """
    arr7 = np.concatenate((arr4, arr5))
    print(arr7)
    """
    [[ 0  1  2  3  4]
     [ 5  6  7  8  9]
     [10 11 12 13 14]
     [15 16 17 18 19]]
    """
    ```

##### 数组的拆分

+ `np.hsplit(ary, indices_or_sections)` : 将一个数组**水平**分割为多个子数组（按列）

  + 参数

    | 参数                    | 描述                                                         |
    | ----------------------- | ------------------------------------------------------------ |
    | **ary**                 | 传入数组                                                     |
    | **indices_or_sections** | 拆分次数是数组长度加一。一个整数N或者一个1-D数组。为N时，在axis方向上平均分割成N份。当给定一个1-D数组时，该数组必须是从小到大排序的整数元素。然后，形成切片式的区间.在第二个轴即1轴方向上切割，分割列 |

  + 实例

    ```python
    import numpy as np
    
    arr = np.arange(16).reshape(2, 8)
    
    print(arr)
    """
    [[ 0  1  2  3  4  5  6  7]
     [ 8  9 10 11 12 13 14 15]]
    """
    
    # hsplit 按列拆分
    print(np.hsplit(arr, [1, 2, 3, 4, 5, 6, 7]))
    """
    [array([[0], [8]]), 
     array([[1], [9]]), 
     array([[ 2], [10]]), 
     array([[ 3], [11]]), 
     array([[ 4], [12]]), 
     array([[ 5], [13]]), 
     array([[ 6], [14]]), 
     array([[ 7], [15]])]
    """
    print(np.hsplit(arr, [2, 4, 6]))
    """
    [array([[0, 1],
           [8, 9]]), 
     array([[ 2,  3],
           [10, 11]]), 
     array([[ 4,  5],
           [12, 13]]), 
     array([[ 6,  7],
           [14, 15]])]
    """
    ```

    

+ `np.vsplit(ary, indices_or_sections)` : 将一个数组垂直分割为多个子数组（**按行**）

  + 参数

    | 参数                    | 描述                                                         |
    | ----------------------- | ------------------------------------------------------------ |
    | **ary**                 | 传入数组                                                     |
    | **indices_or_sections** | 拆分次数是数组长度加一。一个整数N或者一个1-D数组。为N时，在axis方向上平均分割成N份。当给定一个1-D数组时，该数组必须是从小到大排序的整数元素。然后，形成切片式的区间.在第一个轴即0轴方向上切割，分割行 |

  + 实例

    ```python
    import numpy as np
    
    arr = np.arange(16).reshape(2, 8)
    
    # vsplit 按行拆分 拆分三次: 
    # 第 0 行到第一行拆分一次
    # 第一行到第二行拆分一次,
    # 第二行到最后拆分一次
    print(np.vsplit(arr, [1, 2]))
    # 拆分两次
    # 第0行到第一行拆分一次
    # 第一行到最后一行拆分一次
    print(np.vsplit(arr, [1]))
    ```

    

+ `np.split(ary, indices_or_sections, axis=0)` : 将一个数组分割为多个子数组

  + 参数

    | 参数                    | 描述                                                         |
    | ----------------------- | ------------------------------------------------------------ |
    | **axis**                | 轴,默认是0<br>&emsp;**1** : 按列拆分<br>&emsp;**0** : 按行拆分 |
    | **ary**                 | 传入数组                                                     |
    | **indices_or_sections** | 一个整数N或者一个1-D数组。为N时，在axis方向上平均分割成N份。当给定一个1-D数组时，该数组必须是从小到大排序的整数元素。然后，形成切片式的区间 |

  + 实例

    ```python
    import numpy as np
    
    arr = np.arange(16).reshape(2, 8)
    
    print(arr)
    """
    [[ 0  1  2  3  4  5  6  7]
     [ 8  9 10 11 12 13 14 15]]
    """
    
    
    # split 拆分
    # 按行
    print(np.split(arr, [1], axis=0))
    """
    [array([[0, 1, 2, 3, 4, 5, 6, 7]]), 
     array([[ 8,  9, 10, 11, 12, 13, 14, 15]])]
    """
    # 按列
    print(np.split(arr, [2, 4, 6], axis=1))
    """
    [array([[0, 1], [8, 9]]), 
     array([[ 2,  3], [10, 11]]), 
     array([[ 4,  5], [12, 13]]), 
     array([[ 6,  7], [14, 15]])]
    """
    ```

#### 矩阵的创建

+ `np.mat(data, dtype=None)` 与 `np.asmatrix(data, dtype=None)` : 创建一个二维矩阵，类型是 **numpy.matrix**

  1. **特殊字符串**创建矩阵

     ```python
     import numpy as np
     
     m1 = np.mat('1 2 3; 9 8 7; 4 5 6')
     print(m1)
     """
     [[1 2 3]
      [9 8 7]
      [4 5 6]]
     """
     ```

  2. **列表嵌套**创建矩阵

     ```python
     # 列表嵌套创建矩阵
     
     m2 = np.mat([[1, 2, 3],
                  [9, 8, 7],
                  [6, 5, 4]])
     print(m2)
     """
     [[1 2 3]
      [9 8 7]
      [6 5 4]]
     """
     ```

  3. **传入数组**创建矩阵 (使用数组创建的矩阵,矩阵或者数组发生改变,对应的数组和矩阵都会发生改变) **共享内存**

     ```python
     # 传入数组创建矩阵
     
     arr = np.array([[1, 2, 3],
                     [4, 5, 6]])
     
     m3 = np.mat(arr)
     print(m3)
     """
     [[1 2 3]
      [4 5 6]]
     """
     # 更改矩阵 数组也改变
     m3[0, 0] = 100
     print(m3)
     """
     [[100   2   3]
      [  4   5   6]]
     """
     print(arr)
     """
     [[100   2   3]
      [  4   5   6]]
     """
     # 更改数组， 矩阵也发生改变
     arr[0, 1] = 200
     print(arr)
     """
     [[100 200   3]
      [  4   5   6]]
     """
     print(m3)
     """
     [[100 200   3]
      [  4   5   6]]
     """
     ```

  4. 使用 `np.bmat((obj, ldict=None, gdict=None)` 来组和矩阵 (多个矩阵合并为一个)

     + 参数

       | 参数      | 描述                                                         |
       | --------- | ------------------------------------------------------------ |
       | **obj**   | 字符串或数组变量，输入数据。如果是字符串，则可以通过名称引用当前作用域中的变量。 |
       | **ldict** | **dict 类型**，**可选**,一个字典，用于替换当前帧中的本地操作数。如果*obj*不是字符串或*gdict*为None，*则将*被忽略。 |
       | **gdict** | **dict 类型**，**可选**,一个字典，用于替换当前帧中的全局操作数。如果*obj*不是字符串则忽略 |

     + 实例1. 使用**特殊字符串**

       ```python
       import numpy as np
       
       # 组合矩阵
       m1 = np.mat('1 2 3; 9 8 7; 4 5 6')
       
       m2 = np.mat([[10, 20, 30],
                    [90, 80, 70],
                    [60, 50, 40]])
       
       # 使用特殊字符串,每一个元素就是一个矩阵
       m3 = np.bmat("m1 m2; m1 m1")
       print(m3)
       """
       [[ 1  2  3 10 20 30]
        [ 9  8  7 90 80 70]
        [ 4  5  6 60 50 40]
        [ 1  2  3  1  2  3]
        [ 9  8  7  9  8  7]
        [ 4  5  6  4  5  6]]
       """
       ```

     + 实例2.使用**列表的嵌套**

       ```python
       import numpy as np
       
       # 组合矩阵
       m1 = np.mat('1 2 3; 9 8 7; 4 5 6')
       
       m2 = np.mat([[10, 20, 30],
                    [90, 80, 70],
                    [60, 50, 40]])
       
       # 使用列表的嵌套
       m3 = np.bmat([[m1, m2],
                     [m2, m1]])
       print(m3)
       """
       [[ 1  2  3 10 20 30]
        [ 9  8  7 90 80 70]
        [ 4  5  6 60 50 40]
        [10 20 30  1  2  3]
        [90 80 70  9  8  7]
        [60 50 40  4  5  6]]
       """
       ```

     + 实例3.**传入数组**

       ```python
       import numpy as np
       # 传入数组
       arr = np.array([[1, 2, 3],
                       [4, 5, 6]])
       m3 = np.bmat(arr)
       print(m3)
       """
       [[1 2 3]
        [4 5 6]]
       """
       ```

#### 矩阵的运算

#####  Numpy 广播机制

+ **广播** : Numpy 可以转换这些形状不同的数组，使它们都具有相同的大小，然后再对它们进行运算 

+ 如果两个数组的维数不相同，则元素到元素的操作是不可能的。然而，在 NumPy 中仍然可以对形状不相似的数组进行操作，因为它拥有广播功能。较小的数组会广播到较大数组的大小，以便使它们的形状可兼容。

  ```python
  import numpy as np
  
  m1 = np.mat([[1, 2],
               [2, 3]])
  # 通过广播将 1 变为 2x2 的全1矩阵 然后相加
  print(m1 + 1)
  """
  [[2 3]
   [3 4]]
  """
  ```

+ 广播规则

  1. 让所有输入数组都向其中 shape 最长的数组看齐，shape 中不足的部分都通过在 前面加 1 补齐
  2. 输出数组的 shape 是输入数组 shape 的各个轴上的最大值。
  3. 如果输入数组的某个轴和输出数组的对应轴的长度相同或者其长度为 1 时，这个 数组能够用来计算，否则出错。
  4. 当输入数组的某个轴的长度为 1 时，沿着此轴运算时都用此轴上的第一组值。

#####  Numpy 矩阵运算

+ **矩阵运算符** 

  + 方法

    | 运算符                                                       | 描述                                                        |
    | ------------------------------------------------------------ | ----------------------------------------------------------- |
    | `+` ==> `add(x, y)`                                          | 数组中数据逐位相加                                          |
    | `-` ==> `subtract(x1，x2)`                                   | 数组中数据逐位相减                                          |
    | `*` ==> `np.dot(x, y)` ==> `matmul(x1, x2, *args, **kwargs)` | 矩阵 A 的行的元素 乘以 矩阵 B 的对应列的元素 得到的值再相加 |
    | `/` ==> `divide(x1，x2)`                                     |                                                             |
    | `**`                                                         | 平方根                                                      |
    | `>`                                                          | 数组比较,返回布尔值                                         |
    | `<`                                                          | 数组比较,返回布尔值                                         |
    | `%`                                                          | 取余判断，返回布尔数组                                      |
    | `np.multiply(x1, x2, *args, **kwargs)`                       | 两数组对应位置上值相乘 (对应元素相乘)                       |

  + 实例

    ```python
    import numpy as np
    
    m1 = np.mat([[1, 2],
                 [2, 3]])
    
    m2 = np.mat([[1, 0],
                 [0, 1]])
    
    print(m1 + m2)
    """
    [[2 2]
     [2 4]]
    """
    
    print(m1 * m2)
    """
    [[1 2]
     [2 3]]
    """
    print(np.multiply(m1, m2))
    """
    [[1 0]
     [0 3]]
    """
    print(np.dot(m1, m2))
    """
    [[1 2]
     [2 3]]
    """
    print(np.matmul(m1, m2))
    """
    [[1 2]
     [2 3]]
    """
    ```

    

+ 数组特殊运算方法

  + 方法

    | 方法                                     | 描述                                                         |
    | ---------------------------------------- | ------------------------------------------------------------ |
    | `sum()`                                  | 将所有元素相加                                               |
    | `min()`                                  | 找出最小元素                                                 |
    | `max()`                                  | 找出最大元素                                                 |
    | `cumsum()`                               | 逐位相加求和并放入新数组                                     |
    | `np.abs(x)`、`np.fabs(x)`                | 计算数组各元素的绝对值                                       |
    | `np.square(x)`                           | 计算数组各元素的平方                                         |
    | `np.sqrt(x)`                             | 平方根                                                       |
    | `np.log(x)`、`np.log10(x)`、`np.log2(x)` | 计算数组各元素的**自然对数**、10底对数和2底对数              |
    | `arr_name.T`                             | **转置** `.T ` 将A的所有元素绕着一条从第1行第1列元素出发的右下方45度的射线作镜面反 |
    | `np.transpose()`                         | 颠倒 (调换数组的行列值的索引值，类似于求矩阵的转置)          |

  + 实例

    ```python
    import numpy as np
    
    arr = np.arange(20).reshape(4, 5)
    arr1 = np.arange(20, 40).reshape(4, 5)
    """
    arr : 
    [[ 0  1  2  3  4]
     [ 5  6  7  8  9]
     [10 11 12 13 14]
     [15 16 17 18 19]]
    arr1 :
    [[20 21 22 23 24]
     [25 26 27 28 29]
     [30 31 32 33 34]
     [35 36 37 38 39]]
    """
    print(sum(arr, arr1))
    """
    [[50 55 60 65 70]
     [55 60 65 70 75]
     [60 65 70 75 80]
     [65 70 75 80 85]]
    """
    print(f"arr最大值: {np.max(arr)}, arr1 最大值: {np.max(arr1)}")  # arr最大值: 19, arr1 最大值: 39
    print(f"arr最小值: {np.min(arr)}, arr1 最小值: {np.min(arr1)}")  # arr最小值: 0, arr1 最小值: 20
    print(f"arr逐位相加: {np.cumsum(arr)}") 
    """
    arr逐位相加: [  0   1   3   6  10  15  21  28  36  45  55  66  78  91 105 120 136 153 171 190]
    """
    print(f"arr1逐位相加: {np.cumsum(arr1)}")
    """
    arr1逐位相加: [ 20  41  63  86 110 135 161 188 216 245 275 306 338 371 405 440 476 513 551 590]
    """
    ```

####  矩阵的属性

+ 矩阵的属性

  | 属性     | 描述                                                         |
  | -------- | ------------------------------------------------------------ |
  | **.T**   | 矩阵的**转置** (将A的所有元素绕着一条从第1行第1列元素出发的右下方45度的射线作镜面反转，即得到A的转置。) |
  | **.H**   | 矩阵的共轭转置 (**共轭**: **实数的共轭**是实数本身;**负数的共轭**是符号转变 a+bi --共轭--> a-bi) |
  | **.A**   | 矩阵的视图,就是对应的数组                                    |
  | **.I**   | 逆矩阵 (设 A 是一个n阶矩阵，若存在另一个n阶矩阵**B**，使得： **AB=BA=E** ，则称方阵A可逆，并称方阵B是A的逆矩阵) |
  | 其他属性 | 与数组类似都有 **dtype**、**shape**、**size**、**ndim** 等   |
