# Day_08

### 函数

+ 命名空间
    + 保存程序中变量名和值的地方，本质上是一个字典
    + 三种命名空间
        1. 局部命名空间
            + 函数内部命名
        
        2. 全局命名空间
            + 整个代码全局命名
        
        3. 内置命名空间
        
        4. 命名空间查找顺序
            + 局部 > 全局 > 内置
            + 嵌套函数查找
                + 当前函数 (lambda) 命名空间 > 父函数命名空间 > 模块命名空间 > 内置命名空间
        
        5. 命名空间加载顺序
            内置命名空间 (程序运行前加载) --> 全局命名空间 (程序运行时加载) --> 局部命名空间 (程序运行中，函数被调用时加载)

    ```python
  def fun(msg):
      age = 18
      print(locals())
      # 查看当前函数局部命名空间 {'nsg': 12, 'age': 18}
    
    
  name = "小明"
  fun(12)
  print(globals())
  # 查看全局命名空间
  # {'__name__': '__main__', '__package__': None, '__loader__': <_frozen_importlib_external.SourceFileLoader object at 
  # 0x0000027DE7A9E9E8>, '__spec__': None, '__annotations__': {}, '__builtins__': <module 'builtins' (built-in)>, 
  # '__file__': 'E:/python_study/思维导图/python_zhonggong_study/Day_08/Day_08.py', '__cached__': None, 'fun': <function 
  # fun at 0x0000027D8052BF28>, 'name': '小明'} 
    ```

+ 作用域
    + 概述: 变量在程序中可应用范围 (按搜索作用域顺序 : LEGB)
        + Local (函数内部) : 局部作用域
        + Enclosing (嵌套函数外层函数内部) : 嵌套作用域 (闭包)
        + Global (模块全局) : 全局作用域
        + Built-in (内建) : 內建作用域

+ 全局变量和局部变量
    + 局部变量: 在函数内定义的变量，作用域为此函数内部
    + 全局变量: 在程序刚开始定义的变量，作用域为整个程序
        + 变量为不可变数据类型 --> 函数无法修改变量值
        + 变量为可变数据类型 --> 函数可以修改变量值
    + global 和 nonlocal 关键字
        + global : 将局部变量转化为全局变量
        + nonlocal : 修改外层 (非全局) 变量
     
+ 系统内建高阶函数
    + abs() : 返回负数绝对值或复数的模
        ```
      # abs(x)   
      abs(-6)=6
      ```
    + max(iterable, key, default) : 返回给定参数最大值
        + iterable 迭代器 : 迭代器将每一个返回值当做参数传给 key=func 中的 (一般为 lambda 表达式)，然后将 func 执行结果传递给 key，以key为标准判断大小
        + 字典内可以比较，字典与字典不可以直接比较，可以根据相同的key比较
        ```
      # 简单使用
      d1 = {'a': 3, 'b': 4}
      max(d1)  
      # b
      # key 关键字 (key == 函数名称, --> 求最大值的规则)
      >>> max(1,2,-3, key=abs)
      -3
      # 字典比较
      ```
    + map(函数, 可迭代序列) : 根据提供的函数，对指定的序列做映射
        ```
      >>> list(map(lambda x: x**2, [1,2,3]))
      [1, 4, 9]
      ```
    + filter(函数, 可迭代序列) : 用于过滤序列，过滤掉不符合条件的函数，返回由符合条件元素组成的新列表 
        ```
      >>> list(filter(lambda x: x%2==0, [4,5,6,7]))
      [4, 6]
      ```
    + zip() : 将可迭代对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的对象，节约内存 (若多个可迭代对象长度不一致，返回最短长度的可迭代数列值)
        ```
      >>> list(zip([1,2,3,4,5,6], [3,53,6]))
      [(1, 3), (2, 53), (3, 6)]
      >>> list(map(lambda t: {t[0]: t[1]}, zip(a, b)))
      [{'a': 'c'}, {'b': 'd'}]
      >>> list(map(lambda t: dict([t]), zip(lis, lis2)))
      [{1: 4}, {2: 5}, {3: 6}, {4: 7}, {5: 8}]
      ```

+ 匿名函数 : lambda 表达式
    + 语法 : 变量名 = lambda 参数 : 表达式(block)
        + 参数 : 可选，通常以 "," 分隔的变量表达式形式，也就是位置参数
        + 表达式 : 不能包含循环、return，可以包含 if...else... ， 计算结果直接返回
    + 嵌套作用域和lambda : 在def 定义的函数内嵌套 lambda 表达式，lambda 表达式可以看见所有 def 定义的函数中的可用变量

+ 闭包 : (在函数中定义的函数！通过闭包将不同功能模块分离)
    + 全局污染 : 全局变量大量出现容易导致重名现象，将独立的某个功能组件，单独在一个函数中实现，最终通过函数与函数之间局部变量的隔离，达到变量数据的隔离

+ 装饰器
    + 语法:
        ```
      def 装饰器名称(fn):
        def wrapper(*args, **kwargs):
            目标函数执行前，要添加的代码功能
            res = fn(*args, **kwargs)
            目标函数执行后，要添加的代码
        return res
      return wrapper
      ```
    + 装饰器的应用 : 身份验证、授权验证、资源访问、日志记录、时间统计
        + 装饰器的添加
        + 目标函数的参数
        + 目标函数返回值